package user







































































}	return u, nil	}		return nil, fmt.Errorf("failed to update user: %w", err)	if err := uc.userRepo.Save(ctx, u); err != nil {	// Save updated user	}		u.Phone = *input.Phone	if input.Phone != nil {	}		u.Email = *input.Email		}			return nil, fmt.Errorf("email already in use")		if existingUser != nil && existingUser.ID != input.UserID {		existingUser, _ := uc.userRepo.FindByEmail(ctx, *input.Email)		// Check if email is already taken	if input.Email != nil && *input.Email != "" {	// Update fields	}		}			return nil, fmt.Errorf("unauthorized: cannot update another user's profile")		if currentRole != user.Admin {		currentRole, _ := ctx.Value("user_role").(user.Role)	if !ok || currentUserID != input.UserID {	currentUserID, ok := ctx.Value("user_id").(string)	// Check authorization - user can only update their own profile	}		return nil, fmt.Errorf("user not found: %w", err)	if err != nil {	u, err := uc.userRepo.FindByID(ctx, input.UserID)	// Find existing user	}		return nil, fmt.Errorf("user ID is required")	if input.UserID == "" {	// Validate inputfunc (uc *UpdateUserUseCase) Execute(ctx context.Context, input UpdateUserInput) (*user.User, error) {// Execute updates a user's information}	}		userRepo: userRepo,	return &UpdateUserUseCase{func NewUpdateUserUseCase(userRepo user.Repository) *UpdateUserUseCase {// NewUpdateUserUseCase creates a new UpdateUserUseCase}	userRepo user.Repositorytype UpdateUserUseCase struct {// UpdateUserUseCase handles updating user information}	Phone  *string	Email  *string	UserID stringtype UpdateUserInput struct {// UpdateUserInput represents the input for updating a user)	"github.com/yourusername/yourproject/internal/domain/user"	"fmt"	"context"import (package user